package one.clproto.fuse_messages;

message ChannelRegistration {
    required string fuse_id = 1;
}

message ChannelClose {
    required string fuse_id = 1;
}

message FuseMessage {
    required string message_type = 1;
    required bytes input = 2;
}

message GetFileLocation {
    required string file_logic_name = 1;
    optional string open_mode = 2 [default = ""];
    optional bool force_cluster_proxy = 3 [default = false];
}

message GetNewFileLocation {
    required string file_logic_name = 1;
    required uint32 mode = 2;
    optional bool force_cluster_proxy = 3 [default = false];
}

message SetXAttr {
    required string file_logic_name = 1;
    required string name = 2;
    required string value = 3;
    optional int32 flags = 4 [default = 0];
}

message GetXAttr {
    required string file_logic_name = 1;
    required string name = 2;
}

message ListXAttr {
    required string file_logic_name = 1;
}

message RemoveXAttr {
    required string file_logic_name = 1;
    required string name = 2;
}

message XAttr {
    optional string answer = 1 [default = "ok"];
    required string name = 2;
    required string value = 3;
}

message XAttrList {
    message XAttrEntry {
        required string name = 1;
        required string value = 2;
    }

    optional string answer = 1 [default = "ok"];
    repeated XAttrEntry attrs = 2;
}

message AccessControlEntity {
    required uint32 acetype = 1;
    required string identifier = 2;
    required uint32 aceflags = 3;
    required uint32 acemask = 4;
}

message GetAcl {
    required string file_logic_name = 1;
}

message Acl {
    optional string answer = 1 [default = "ok"];
    repeated AccessControlEntity entities = 2;
}

message SetAcl {
    required string file_logic_name = 1;
    repeated AccessControlEntity entities = 2;
}

message GetFileAttr {
    required string file_logic_name = 1;
}

message FileAttr {
    optional string answer = 1 [default = "ok"];
    required int32 mode = 2;
    required int32 uid = 3;
    required int32 gid = 4;
    required int64 atime = 5;
    required int64 mtime = 6;
    required int64 ctime = 7;
    required string type = 9;
    optional int64 size = 10 [default = 0];
    optional string uname = 11 [default = ""];
    optional string gname = 12 [default = ""];
    optional int32 links = 13 [default = 1];
    optional bool has_acl = 14 [default = false];
    required string uuid = 15;
}

message GetFileUuid {
    required string file_logic_name = 1;
}

message FileUuid {
    optional string answer = 1 [default = "ok"];
    required string uuid = 2;
}

message FileLocation {
    message BlockAvailability {
        required uint64 offset = 1;
        required uint64 size = 2;
    }

    optional string answer = 1 [default = "ok"];
    required uint32 storage_id = 2;
    required string file_id = 3;
    required uint32 validity = 4;
    optional string storage_helper_name = 5;
    repeated string storage_helper_args = 6;
    repeated BlockAvailability available = 7;
}

message BlocksAvailable {
    optional bool clear_map = 1 [default = false];
    required uint32 storage_id = 2;
    required string file_id = 3;
    repeated FileLocation.BlockAvailability blocks = 4;
}

message RequestFileBlock {
    required string logical_name = 1;
    required uint64 offset = 2;
    required uint64 size = 3;
}

message SynchronizeFileBlock {
    required string logical_name = 1;
    required uint64 offset = 2;
    required uint64 size = 3;
}

message FileBlockModified {
    required string logical_name = 1;
    required uint64 offset = 2;
    required uint64 size = 3;
}

message FileTruncated {
    required string logical_name = 1;
    required uint64 size = 2;
}

message CreateFileAck {
    required string file_logic_name = 1;
}

message FileNotUsed {
    required string file_logic_name = 1;
}

message RenewFileLocation {
    required string file_logic_name = 1;
}

message FileLocationValidity {
    optional string answer = 1 [default = "ok"];
    optional int32 validity = 2;
}

message GetFileChildrenCount {
    required string dir_logic_name = 1;
}

message FileChildrenCount {
    optional string answer = 1 [default = "ok"];
    required uint32 count = 2;
}

message GetFileChildren {
    required string dir_logic_name = 1;
    required int32 children_num = 2;
    optional int32 offset = 3 [default = 0];
}

message FileChildren {
    message DirEntry {
        required string name = 1;
        required string type = 2;
    }

    optional string answer = 1 [default = "ok"];
    repeated DirEntry entry = 2;
}

message CreateDir {
    required string dir_logic_name = 1;
    required uint32 mode = 2;
}

message DeleteFile {
    required string file_logic_name = 1;
}

message CreateLink {
    required string from_file_logic_name = 1;
    required string to_file_logic_name = 2;
}

message GetLink {
    required string file_logic_name = 1;
}

message LinkInfo {
    optional string answer = 1 [default = "ok"];
    required string file_logic_name = 2;
}

message RenameFile {
    required string from_file_logic_name = 1;
    required string to_file_logic_name = 2;
}

message ChangeFileOwner {
    required string file_logic_name = 1;
    required int32 uid = 2;
    optional string uname = 4 [default = ""];
}

message ChangeFileGroup {
    required string file_logic_name = 1;
    required int32 gid = 3;
    optional string gname = 5 [default = ""];
}

message ChangeFilePerms {
    required string file_logic_name = 1;
    required int32 perms = 2;
}

message CheckFilePerms {
    required string file_logic_name = 1;
    required string type = 2 [default = "root"];
}

message UpdateTimes {
    required string file_logic_name = 1;
    optional int64 atime = 2 [default = -1];
    optional int64 mtime = 3 [default = -1];
    optional int64 ctime = 4 [default = -1];
}

message TestChannel {
    required string answer_message = 1;
    required int32 answer_delay_in_ms = 2;
}

message TestChannelAnswer {
    required string message = 1;
}

message HandshakeRequest {
    required string hostname = 1;

    message EnvVariable {
        required string name = 1;
        required string value = 2;
    }

    repeated EnvVariable variable = 2;

    message CertConfirmation {
        required string login = 1;
        required bool result = 2;
    }

    optional CertConfirmation cert_confirmation = 3;
}

message HandshakeResponse {
    required string fuse_id = 1;
}

message HandshakeAck {
    required string fuse_id = 1;
}

message CreateStorageTestFileRequest {
    required int32 storage_id = 1;
}

message CreateStorageTestFileResponse {
    required bool answer = 1;
    optional string relative_path = 2 [default = ""];
    optional string text = 3 [default = ""];
}

message StorageTestFileModifiedRequest {
    required int32 storage_id = 1;
    required string relative_path = 2;
    required string text = 3;
}

message StorageTestFileModifiedResponse {
    required bool answer = 1;
}

message ClientStorageInfo {
    message StorageInfo {
        required int32 storage_id = 1;
        required string absolute_path = 2;
    }
    repeated StorageInfo storage_info = 1;
}

message GetStatFS {
}

message StatFSInfo {
    optional string answer = 1 [default = "ok"];
    required int64 quota_size = 2;
    required int64 files_size = 3;
}

message EventFilterConfig {
    required string field_name = 1;
    required string desired_value = 2;
}

message EventAggregatorConfig {
    required string field_name = 1;
    required uint64 threshold = 2;
    required string sum_field_name = 3; // it will be extended in future. so far we assume that aggregation function is always sum and sum_field_name is field_name which values are summed
}

// configure stream in client. Enables changing event values.
message EventTransformerConfig {
    repeated string field_names_to_replace = 1;
    repeated string values_to_replace = 2;
    repeated string new_values = 3;
}

// EventStreamConfig is a message sent by cluster to client which contains informations needed for client to perform events processing (filtering, aggregation etc.)
// Only one of fields filter_config and aggregation_config is supposed to be set. Type of EventStreamConfig is determined by the fact which of those two fields is set.
// wrapped_config should be used when one needs to create chain of streams. If wrapped_config is set to contains another EventStreamConfig then the event first go to the most wrapped stream
message EventStreamConfig {
    optional EventStreamConfig wrapped_config = 1;
    optional EventFilterConfig filter_config = 2;
    optional EventAggregatorConfig aggregator_config = 3;
    optional EventTransformerConfig transformer_config = 4;
    repeated string needed_envs = 5; // list of environment variables needed for EventStream
}

message EventProducerConfig {
    repeated EventStreamConfig event_streams_configs = 1;
}

// Generic event message.
// TODO: add support for multiple values per one key
message EventMessage {
    message Block {
        required uint64 offset = 1;
        required uint64 size = 2;
    }
    repeated string numeric_properties_keys = 1; // numericPropertiesKeys length is expected to be equal numericPropertiesValues length
    repeated int64 numeric_properties_values = 2;
    repeated string string_properties_keys = 3; // stringPropertiesKeys length is expected to be equal stringPropertiesValues length
    repeated string string_properties_values = 4;
    repeated Block block = 5;
}
